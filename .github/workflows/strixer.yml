name: Strixer - Direct CLIProxyAPI Security Scan

on:
  workflow_dispatch:
    inputs:
      decryption_password:
        description: 'Password to decrypt QWEN_TOKENS'
        required: true
        type: string
      target:
        description: 'Target to scan (URL, path, or repository)'
        required: true
        default: './'
        type: string
      prompt:
        description: 'Custom instructions for the AI agent'
        required: false
        default: ''
        type: string
      timeframe:
        description: 'Maximum runtime in minutes (10-720) - Strix requires minimum 10 minutes'
        required: false
        default: '60'
        type: choice
        options:
          - '10'
          - '15'
          - '30'
          - '60'
          - '90'
          - '120'
          - '180'
          - '240'
          - '360'
          - '480'
          - '720'
      warning_minutes:
        description: 'Minutes before end to warn AI (1-30)'
        required: false
        default: '5'
        type: choice
        options:
          - '1'
          - '2'
          - '3'
          - '5'
          - '10'
          - '15'
          - '20'
          - '30'
      scan_mode:
        description: 'Scan mode'
        required: false
        default: 'deep'
        type: choice
        options:
          - quick
          - standard
          - deep
      model:
        description: 'Qwen AI Model to use'
        required: false
        default: 'qwen3-coder-plus'
        type: choice
        options:
          - 'qwen3-coder-plus'
          - 'qwen3-coder-flash'
          - 'qwen3-max'
          - 'qwen-plus'
          - 'qwen-turbo'
          - 'qwen-long'
          - 'qwen2.5-coder-32b-instruct'
          - 'qwen2.5-72b-instruct'
      enable_strixdb:
        description: 'Enable StrixDB artifact storage'
        required: false
        default: true
        type: boolean
      enable_dashboard:
        description: 'Enable real-time web dashboard'
        required: false
        default: true
        type: boolean

concurrency:
  group: strixer-${{ github.head_ref || github.ref }}
  cancel-in-progress: true

env:
  DEFAULT_TIMEFRAME: '60'
  DEFAULT_WARNING_MINUTES: '5'
  DEFAULT_SCAN_MODE: 'standard'
  CLIPROXY_PORT: '8317'
  DASHBOARD_PORT: '8080'

jobs:
  strixer-scan:
    name: Strixer Security Scan (Direct CLIProxyAPI)
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
      pull-requests: write

    steps:
      - name: Compute timeout
        id: vars
        run: |
          set -euo pipefail
          TF="${{ github.event.inputs.timeframe || env.DEFAULT_TIMEFRAME }}"
          if ! [[ "$TF" =~ ^[0-9]+$ ]]; then
            echo "Invalid timeframe: $TF" >&2
            exit 1
          fi
          echo "timeout=$(( TF + 30 ))" >> "$GITHUB_OUTPUT"

      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Go Environment
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      - name: Setup Python Environment
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install Cloudflared for Dashboard Tunnel
        if: ${{ github.event.inputs.enable_dashboard == 'true' || github.event.inputs.enable_dashboard == '' }}
        run: |
          set -euo pipefail
          echo "::group::Installing Cloudflared"
          # Download and install cloudflared
          curl -L --output cloudflared.deb https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i cloudflared.deb
          rm cloudflared.deb
          echo "Cloudflared installed: $(cloudflared --version)"
          echo "::endgroup::"

      - name: Decrypt Qwen Tokens
        id: decrypt
        run: |
          set -euo pipefail
          echo "::group::Decrypting Qwen tokens"
          if [ -z "${{ secrets.QWEN_TOKENS }}" ]; then
            echo "::error::QWEN_TOKENS secret is not set"
            exit 1
          fi
          mkdir -p ~/.cli-proxy-api
          cd ~/.cli-proxy-api
          echo "${{ secrets.QWEN_TOKENS }}" | base64 -d > qwen-tokens.enc
          if ! echo "${{ github.event.inputs.decryption_password }}" | openssl enc -aes-256-cbc -d -salt -pbkdf2 -in qwen-tokens.enc -out qwen-tokens.tar.gz -pass stdin 2>/dev/null; then
            echo "::error::Failed to decrypt tokens. Invalid password"
            exit 1
          fi
          tar -xzf qwen-tokens.tar.gz
          for dir in account-*/; do
            [ -d "$dir" ] && mv "$dir"qwen-*.json . 2>/dev/null || true
          done
          TOKEN_COUNT=$(find . -maxdepth 1 -name 'qwen-*.json' | wc -l)
          if [ "$TOKEN_COUNT" -eq 0 ]; then
            echo "::error::No token files found after decryption"
            exit 1
          fi
          echo "Successfully decrypted $TOKEN_COUNT Qwen account(s)"
          echo "token_count=$TOKEN_COUNT" >> "$GITHUB_OUTPUT"
          rm -f qwen-tokens.enc qwen-tokens.tar.gz
          echo "::endgroup::"
          
      - name: Install CLIProxyAPI
        run: |
          set -euo pipefail
          echo "::group::Installing CLIProxyAPI"
          git clone --depth 1 https://github.com/router-for-me/CLIProxyAPI.git /tmp/CLIProxyAPI
          cd /tmp/CLIProxyAPI
          go build -o cli-proxy-api ./cmd/server
          sudo mv cli-proxy-api /usr/local/bin/
          if ! cli-proxy-api --help >/dev/null 2>&1; then
            echo "::error::CLIProxyAPI failed to install"
            exit 1
          fi
          echo "CLIProxyAPI installed"
          echo "::endgroup::"
          
      - name: Configure CLIProxyAPI
        run: |
          set -euo pipefail
          echo "::group::Configuring CLIProxyAPI"
          AUTH_DIR="$HOME/.cli-proxy-api"
          cat > "$AUTH_DIR/config.yaml" << 'EOF'
          host: "127.0.0.1"
          port: 8317
          auth-dir: "~/.cli-proxy-api"
          debug: true
          logging-to-file: true
          request-retry: 5
          max-retry-interval: 60
          quota-exceeded:
            switch-project: true
            switch-preview-model: true
          routing:
            strategy: "round-robin"
          EOF
          sed -i 's/^          //' "$AUTH_DIR/config.yaml"
          echo "Configuration created:"
          cat "$AUTH_DIR/config.yaml"
          echo "::endgroup::"

      - name: Start CLIProxyAPI Server
        id: cliproxy
        run: |
          set -euo pipefail
          echo "::group::Starting CLIProxyAPI Server"
          AUTH_DIR="$HOME/.cli-proxy-api"
          cd "$AUTH_DIR"
          
          # List token files for debugging
          echo "Token files found:"
          ls -la qwen-*.json 2>/dev/null || echo "No qwen token files found!"
          
          nohup cli-proxy-api -config config.yaml > cliproxy.log 2>&1 &
          SERVER_PID=$!
          echo "$SERVER_PID" > cliproxy.pid
          sleep 15
          
          if ! kill -0 $SERVER_PID 2>/dev/null; then
            echo "::error::CLIProxyAPI failed to start"
            cat cliproxy.log || echo "No log file"
            exit 1
          fi
          
          # Wait for server to be ready
          for i in {1..20}; do
            MODELS_RESPONSE=$(curl -s "http://127.0.0.1:${{ env.CLIPROXY_PORT }}/v1/models" 2>/dev/null || true)
            if [ -n "$MODELS_RESPONSE" ] && echo "$MODELS_RESPONSE" | jq -e '.data' > /dev/null 2>&1; then
              echo "CLIProxyAPI is ready!"
              echo "Available models:"
              echo "$MODELS_RESPONSE" | jq -r '.data[].id' 2>/dev/null | head -20 || true
              break
            fi
            echo "Waiting for CLIProxyAPI... (attempt $i/20)"
            sleep 3
          done
          
          # Show startup logs
          echo "CLIProxyAPI startup logs:"
          head -50 cliproxy.log || true
          
          ENDPOINT="http://127.0.0.1:${{ env.CLIPROXY_PORT }}/v1"
          echo "endpoint=$ENDPOINT" >> "$GITHUB_OUTPUT"
          echo "pid=$SERVER_PID" >> "$GITHUB_OUTPUT"
          echo "=========================================="
          echo "CLIPROXYAPI READY (DIRECT HTTP MODE)"
          echo "Endpoint: $ENDPOINT"
          echo "Accounts: ${{ steps.decrypt.outputs.token_count }}"
          echo "Model: ${{ github.event.inputs.model || 'qwen3-coder-plus' }}"
          echo "=========================================="
          echo "::endgroup::"

      - name: Setup Direct CLIProxyAPI Environment
        run: |
          echo "::group::Setting up Direct CLIProxyAPI environment (NO LiteLLM)"
          
          # Direct CLIProxyAPI mode - NO LiteLLM dependency
          echo "CLIPROXY_ENDPOINT=${{ steps.cliproxy.outputs.endpoint }}" >> "$GITHUB_ENV"
          echo "CLIPROXY_MODEL=${{ github.event.inputs.model || 'qwen3-coder-plus' }}" >> "$GITHUB_ENV"
          
          # Dummy API key for CLIProxyAPI OAuth mode
          echo "OPENAI_API_KEY=cliproxy-direct-mode" >> "$GITHUB_ENV"
          echo "OPENAI_API_BASE=${{ steps.cliproxy.outputs.endpoint }}" >> "$GITHUB_ENV"
          
          # Test the endpoint directly
          echo "Testing CLIProxyAPI endpoint directly..."
          curl -s "${{ steps.cliproxy.outputs.endpoint }}/models" | jq '.data | length' || echo "Could not get model count"
          
          # Test a simple completion request
          echo "Testing direct chat completion..."
          RESPONSE=$(curl -s -X POST "${{ steps.cliproxy.outputs.endpoint }}/chat/completions" \
            -H "Content-Type: application/json" \
            -d '{
              "model": "${{ github.event.inputs.model || 'qwen3-coder-plus' }}",
              "messages": [{"role": "user", "content": "Say OK"}],
              "max_tokens": 10
            }' 2>/dev/null || echo "{}")
          
          if echo "$RESPONSE" | jq -e '.choices[0].message.content' > /dev/null 2>&1; then
            echo "Direct CLIProxyAPI test successful!"
            echo "$RESPONSE" | jq -r '.choices[0].message.content'
          else
            echo "::warning::Direct API test did not return expected format"
            echo "Response: $RESPONSE"
          fi
          echo "::endgroup::"

      - name: Install Strix (No LiteLLM)
        run: |
          set -euo pipefail
          echo "::group::Installing Strix (Direct CLIProxyAPI Mode)"
          git clone --depth 1 https://github.com/Hailer367/strix.git /tmp/strix
          cd /tmp/strix
          pip install -q poetry
          poetry config virtualenvs.create false
          
          # Install Strix with minimal dependencies (skip litellm if possible)
          # For now install normally, the direct HTTP mode will bypass LiteLLM at runtime
          poetry install --no-interaction --quiet
          
          # Verify installation
          python -c "from strix.interface.main import app; print('Strix CLI loaded')" 2>/dev/null || echo "Strix CLI loaded"
          echo "Strix installation complete (Direct CLIProxyAPI Mode)"
          echo "::endgroup::"

      - name: Start Web Dashboard Server
        id: dashboard
        if: ${{ github.event.inputs.enable_dashboard == 'true' || github.event.inputs.enable_dashboard == '' }}
        run: |
          set -euo pipefail
          echo "::group::Starting Web Dashboard"
          
          # Create a shared state file that both dashboard and strix can use
          SHARED_STATE_FILE="/tmp/strix_dashboard_state.json"
          echo '{}' > "$SHARED_STATE_FILE"
          chmod 666 "$SHARED_STATE_FILE"
          export STRIX_DASHBOARD_STATE_FILE="$SHARED_STATE_FILE"
          
          # Create dashboard launcher script with state file monitoring
          cat > /tmp/start_dashboard.py << 'PYEOF'
          import sys
          import os
          import json
          import time
          import signal
          from datetime import datetime, UTC
          from pathlib import Path
          
          sys.path.insert(0, '/tmp/strix')
          
          from strix.dashboard.web_server import start_web_dashboard, update_dashboard_state, get_dashboard_state
          
          # Get shared state file path from environment
          STATE_FILE = os.environ.get('STRIX_DASHBOARD_STATE_FILE', '/tmp/strix_dashboard_state.json')
          
          def signal_handler(sig, frame):
              print("Dashboard shutting down...")
              sys.exit(0)
          
          signal.signal(signal.SIGTERM, signal_handler)
          signal.signal(signal.SIGINT, signal_handler)
          
          # Start dashboard
          server = start_web_dashboard(host='0.0.0.0', port=8080)
          print(f"Dashboard running at http://localhost:8080")
          print(f"Monitoring state file: {STATE_FILE}")
          
          # Initialize with scan config from environment
          target = os.environ.get('SCAN_TARGET', 'Unknown')
          prompt = os.environ.get('SCAN_PROMPT', '')
          timeframe = int(os.environ.get('SCAN_TIMEFRAME', '60'))
          warning = int(os.environ.get('SCAN_WARNING', '5'))
          start_time = datetime.now(UTC)
          
          update_dashboard_state({
              "scan_config": {
                  "targets": [{"original": target, "type": "web_application", "details": {"target_url": target}}],
                  "user_instructions": prompt,
              },
              "time": {
                  "start_time": start_time.isoformat(),
                  "duration_minutes": timeframe,
                  "warning_minutes": warning,
                  "elapsed_minutes": 0,
                  "remaining_minutes": timeframe,
                  "progress_percentage": 0,
                  "status": "ðŸŸ¢ Starting scan...",
                  "is_warning": False,
                  "is_critical": False,
              }
          })
          
          last_mtime = 0
          last_content_hash = None
          update_count = 0
          
          # Keep running and monitor state file for updates
          while True:
              try:
                  # Check if state file was updated by strix
                  if Path(STATE_FILE).exists():
                      mtime = Path(STATE_FILE).stat().st_mtime
                      if mtime > last_mtime:
                          last_mtime = mtime
                          try:
                              with open(STATE_FILE, 'r') as f:
                                  content = f.read()
                              if content and content.strip():
                                  # Check if content actually changed (not just mtime)
                                  content_hash = hash(content)
                                  if content_hash != last_content_hash:
                                      last_content_hash = content_hash
                                      external_state = json.loads(content)
                                      if external_state and isinstance(external_state, dict):
                                          # Log state updates periodically
                                          update_count += 1
                                          if update_count % 10 == 1:  # Log every 10th update
                                              agents_count = len(external_state.get('agents', {}))
                                              tools_count = len(external_state.get('tool_executions', []))
                                              vulns_count = len(external_state.get('vulnerabilities', []))
                                              print(f"State update #{update_count}: agents={agents_count}, tools={tools_count}, vulns={vulns_count}")
                                          update_dashboard_state(external_state)
                          except json.JSONDecodeError as je:
                              print(f"JSON parse error: {je}")
                          except Exception as re:
                              print(f"State file read error: {re}")
                  
                  # Update time tracking
                  elapsed = (datetime.now(UTC) - start_time).total_seconds() / 60.0
                  remaining = max(0.0, timeframe - elapsed)
                  progress = min(100.0, (elapsed / timeframe) * 100) if timeframe > 0 else 0
                  
                  is_warning = remaining <= warning
                  is_critical = remaining <= (warning / 2)
                  
                  if remaining <= 0:
                      status = "â° TIME EXPIRED"
                  elif is_critical:
                      status = f"ðŸ”´ {remaining:.1f}m remaining (CRITICAL)"
                  elif is_warning:
                      status = f"ðŸŸ¡ {remaining:.1f}m remaining (Warning)"
                  else:
                      status = f"ðŸŸ¢ {remaining:.1f}m remaining ({progress:.0f}%)"
                  
                  update_dashboard_state({
                      "time": {
                          "elapsed_minutes": elapsed,
                          "remaining_minutes": remaining,
                          "progress_percentage": progress,
                          "status": status,
                          "is_warning": is_warning,
                          "is_critical": is_critical,
                      }
                  })
                  
              except Exception as e:
                  print(f"State sync error: {e}")
              
              time.sleep(1)
          PYEOF
          
          # Export environment variables for the dashboard script
          export SCAN_TARGET="${{ github.event.inputs.target }}"
          export SCAN_PROMPT="${{ github.event.inputs.prompt }}"
          export SCAN_TIMEFRAME="${{ github.event.inputs.timeframe || env.DEFAULT_TIMEFRAME }}"
          export SCAN_WARNING="${{ github.event.inputs.warning_minutes || env.DEFAULT_WARNING_MINUTES }}"
          
          # Start dashboard in background with environment variables
          STRIX_DASHBOARD_STATE_FILE="$SHARED_STATE_FILE" \
          SCAN_TARGET="$SCAN_TARGET" \
          SCAN_PROMPT="$SCAN_PROMPT" \
          SCAN_TIMEFRAME="$SCAN_TIMEFRAME" \
          SCAN_WARNING="$SCAN_WARNING" \
          nohup python /tmp/start_dashboard.py > /tmp/dashboard.log 2>&1 &
          DASHBOARD_PID=$!
          echo "$DASHBOARD_PID" > /tmp/dashboard.pid
          
          # Wait for dashboard to start
          sleep 5
          
          if ! kill -0 $DASHBOARD_PID 2>/dev/null; then
            echo "Dashboard failed to start. Logs:"
            cat /tmp/dashboard.log || true
            echo "Continuing without dashboard..."
            echo "dashboard_enabled=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          # Verify dashboard is responding
          for i in {1..10}; do
            if curl -s "http://localhost:${{ env.DASHBOARD_PORT }}/health" > /dev/null 2>&1; then
              echo "Dashboard is healthy!"
              break
            fi
            echo "Waiting for dashboard... (attempt $i/10)"
            sleep 2
          done
          
          echo "dashboard_pid=$DASHBOARD_PID" >> "$GITHUB_OUTPUT"
          echo "dashboard_enabled=true" >> "$GITHUB_OUTPUT"
          echo "state_file=$SHARED_STATE_FILE" >> "$GITHUB_OUTPUT"
          echo "Dashboard started on port ${{ env.DASHBOARD_PORT }}"
          echo "::endgroup::"

      - name: Start Dashboard Tunnel
        id: tunnel
        if: ${{ steps.dashboard.outputs.dashboard_enabled == 'true' }}
        run: |
          set -euo pipefail
          echo "::group::Starting Dashboard Tunnel"
          
          # Start cloudflared tunnel in background
          nohup cloudflared tunnel --url http://localhost:${{ env.DASHBOARD_PORT }} > /tmp/tunnel.log 2>&1 &
          TUNNEL_PID=$!
          echo "$TUNNEL_PID" > /tmp/tunnel.pid
          
          # Wait for tunnel to establish and get URL
          sleep 10
          
          # Extract the tunnel URL from logs
          DASHBOARD_URL=""
          for i in {1..30}; do
            DASHBOARD_URL=$(grep -oE 'https://[a-zA-Z0-9-]+\.trycloudflare\.com' /tmp/tunnel.log | head -1 || true)
            if [ -n "$DASHBOARD_URL" ]; then
              break
            fi
            echo "Waiting for tunnel URL... (attempt $i/30)"
            sleep 2
          done
          
          if [ -z "$DASHBOARD_URL" ]; then
            echo "::warning::Could not establish tunnel. Dashboard will only be accessible locally."
            cat /tmp/tunnel.log || true
            echo "dashboard_url=" >> "$GITHUB_OUTPUT"
          else
            echo "=========================================="
            echo "ðŸŒ LIVE DASHBOARD URL"
            echo "=========================================="
            echo ""
            echo "  $DASHBOARD_URL"
            echo ""
            echo "=========================================="
            echo "Open this URL in your browser to monitor"
            echo "the scan progress in real-time!"
            echo "=========================================="
            echo "dashboard_url=$DASHBOARD_URL" >> "$GITHUB_OUTPUT"
          fi
          
          echo "tunnel_pid=$TUNNEL_PID" >> "$GITHUB_OUTPUT"
          echo "::endgroup::"

      - name: Display Dashboard URL
        if: ${{ steps.tunnel.outputs.dashboard_url != '' }}
        run: |
          echo ""
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘                                                              â•‘"
          echo "â•‘  ðŸ¦‰ STRIXER LIVE DASHBOARD                                   â•‘"
          echo "â•‘                                                              â•‘"
          echo "â•‘  Monitor your scan in real-time at:                          â•‘"
          echo "â•‘                                                              â•‘"
          echo "â•‘  ${{ steps.tunnel.outputs.dashboard_url }}"
          echo "â•‘                                                              â•‘"
          echo "â•‘  Features:                                                   â•‘"
          echo "â•‘  â€¢ Real-time agent activity feed                             â•‘"
          echo "â•‘  â€¢ Multi-agent collaboration view                            â•‘"
          echo "â•‘  â€¢ Vulnerability discoveries                                 â•‘"
          echo "â•‘  â€¢ Tool execution history                                    â•‘"
          echo "â•‘  â€¢ Time remaining countdown                                  â•‘"
          echo "â•‘  â€¢ Resource usage stats                                      â•‘"
          echo "â•‘                                                              â•‘"
          echo "â•‘  MODE: Direct CLIProxyAPI (No LiteLLM)                        â•‘"
          echo "â•‘                                                              â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          
      - name: Create Strix Configuration
        id: config
        run: |
          set -euo pipefail
          echo "::group::Creating Strix Configuration (Direct CLIProxyAPI)"
          TIMEFRAME="${{ github.event.inputs.timeframe || env.DEFAULT_TIMEFRAME }}"
          WARNING="${{ github.event.inputs.warning_minutes || env.DEFAULT_WARNING_MINUTES }}"
          SCAN_MODE="${{ github.event.inputs.scan_mode || env.DEFAULT_SCAN_MODE }}"
          MODEL="${{ github.event.inputs.model || 'qwen3-coder-plus' }}"
          ENABLE_STRIXDB="${{ github.event.inputs.enable_strixdb }}"
          [ -z "$ENABLE_STRIXDB" ] && ENABLE_STRIXDB="true"
          
          # Create config for direct CLIProxyAPI mode (NO LiteLLM prefix needed)
          for CONFIG_DIR in "$GITHUB_WORKSPACE" "/tmp/strix"; do
            cat > "$CONFIG_DIR/config.json" << CONFIGEOF
          {
            "api": {
              "endpoint": "${{ steps.cliproxy.outputs.endpoint }}",
              "model": "$MODEL"
            },
            "timeframe": {
              "duration_minutes": $TIMEFRAME,
              "warning_minutes": $WARNING,
              "time_awareness_enabled": true
            },
            "dashboard": {
              "enabled": true,
              "web_dashboard_enabled": true,
              "web_dashboard_port": ${{ env.DASHBOARD_PORT }}
            },
            "scan_mode": "$SCAN_MODE",
            "direct_api_mode": true
          }
          CONFIGEOF
          done
          
          echo "Configuration Summary (Direct CLIProxyAPI):"
          echo "  - Endpoint: ${{ steps.cliproxy.outputs.endpoint }}"
          echo "  - Model: $MODEL (Direct, no LiteLLM prefix)"
          echo "  - Duration: $TIMEFRAME minutes"
          echo "  - Warning: $WARNING minutes"
          echo "  - Scan Mode: $SCAN_MODE"
          echo "  - Accounts: ${{ steps.decrypt.outputs.token_count }}"
          echo "  - StrixDB: $ENABLE_STRIXDB"
          echo "  - Dashboard: ${{ steps.tunnel.outputs.dashboard_url || 'local only' }}"
          echo "  - API Mode: Direct HTTP (no LiteLLM)"
          echo "::endgroup::"
          
      - name: Prepare Instructions
        id: instructions
        run: |
          set -euo pipefail
          INSTRUCTIONS="${{ github.event.inputs.prompt }}"
          if [ "${{ github.event.inputs.enable_strixdb }}" == "true" ]; then
            INSTRUCTIONS="$INSTRUCTIONS Save useful scripts, tools, exploits, methods to StrixDB."
          fi
          INSTRUCTIONS="$INSTRUCTIONS Use multi-action mode (up to 7 actions per call) for efficiency. Load-balanced across ${{ steps.decrypt.outputs.token_count }} Qwen accounts via CLIProxyAPI."
          INSTRUCTIONS=$(echo "$INSTRUCTIONS" | sed 's/"/\\"/g' | tr -d '\n')
          echo "instructions=$INSTRUCTIONS" >> "$GITHUB_OUTPUT"

      - name: Run Strixer Security Scan
        id: strix
        timeout-minutes: ${{ fromJSON(steps.vars.outputs.timeout) }}
        continue-on-error: true
        env:
          STRIXDB_TOKEN: ${{ secrets.STRIXDB_TOKEN }}
          # Direct CLIProxyAPI mode - model name without provider prefix
          STRIX_LLM: ${{ github.event.inputs.model || 'qwen3-coder-plus' }}
          LLM_API_BASE: ${{ steps.cliproxy.outputs.endpoint }}
          OPENAI_API_KEY: cliproxy-direct-mode
          OPENAI_API_BASE: ${{ steps.cliproxy.outputs.endpoint }}
          # DIRECT CLIProxyAPI endpoint for HTTP requests
          CLIPROXY_ENDPOINT: ${{ steps.cliproxy.outputs.endpoint }}
          CLIPROXY_MODEL: ${{ github.event.inputs.model || 'qwen3-coder-plus' }}
          # Disable Strix's internal dashboard since we're running an external one
          STRIX_WEB_DASHBOARD: 'false'
          STRIX_DASHBOARD_PORT: ${{ env.DASHBOARD_PORT }}
          # Direct API mode settings
          STRIX_DIRECT_API_MODE: 'true'
          # Rate limiting - optimized for CLIProxyAPI multi-account support
          LLM_RATE_LIMIT_DELAY: '0.1'
          LLM_RATE_LIMIT_CONCURRENT: '3'
          LLM_MAX_REQUESTS_PER_MINUTE: '120'
          # Shared state file for dashboard updates
          STRIX_DASHBOARD_STATE_FILE: /tmp/strix_dashboard_state.json
          # Enable host network mode for Docker container
          STRIX_USE_HOST_NETWORK: 'true'
          # Pass search API keys if configured
          PERPLEXITY_API_KEY: ${{ secrets.PERPLEXITY_API_KEY }}
          TAVILY_API_KEY: ${{ secrets.TAVILY_API_KEY }}
          SERPAPI_API_KEY: ${{ secrets.SERPAPI_API_KEY }}
          BRAVE_API_KEY: ${{ secrets.BRAVE_API_KEY }}
          GOOGLE_CSE_API_KEY: ${{ secrets.GOOGLE_CSE_API_KEY }}
          GOOGLE_CSE_ID: ${{ secrets.GOOGLE_CSE_ID }}
        run: |
          set +euo pipefail
          echo "::group::Running Strixer Security Scan (Direct CLIProxyAPI)"
          TARGET="${{ github.event.inputs.target }}"
          TIMEFRAME="${{ github.event.inputs.timeframe || env.DEFAULT_TIMEFRAME }}"
          SCAN_MODE="${{ github.event.inputs.scan_mode || env.DEFAULT_SCAN_MODE }}"
          INSTRUCTIONS="${{ steps.instructions.outputs.instructions }}"
          
          echo "=========================================="
          echo "STRIXER SECURITY SCAN STARTING"
          echo "=========================================="
          echo "Target: $TARGET"
          echo "Timeframe: $TIMEFRAME minutes"
          echo "Scan Mode: $SCAN_MODE"
          echo "Model: ${{ github.event.inputs.model || 'qwen3-coder-plus' }}"
          echo "Accounts: ${{ steps.decrypt.outputs.token_count }}"
          echo "CLIProxyAPI Endpoint: ${{ steps.cliproxy.outputs.endpoint }}"
          echo "API Mode: Direct HTTP (no LiteLLM)"
          if [ -n "${{ steps.tunnel.outputs.dashboard_url }}" ]; then
            echo "Dashboard: ${{ steps.tunnel.outputs.dashboard_url }}"
          fi
          echo "=========================================="
          
          # Verify CLIProxyAPI is still running before starting scan
          echo "Verifying CLIProxyAPI status..."
          if ! curl -s "${{ steps.cliproxy.outputs.endpoint }}/models" > /dev/null 2>&1; then
            echo "::warning::CLIProxyAPI may not be responding. Checking logs..."
            cat ~/.cli-proxy-api/cliproxy.log | tail -20 || true
          else
            echo "CLIProxyAPI is responding."
          fi
          
          cd "$GITHUB_WORKSPACE"
          
          # Export dashboard state file path
          export STRIX_DASHBOARD_STATE_FILE="/tmp/strix_dashboard_state.json"
          
          CMD="python -m strix.interface.main --target \"$TARGET\" --scan-mode $SCAN_MODE --non-interactive"
          if [ -n "$INSTRUCTIONS" ]; then
            CMD="$CMD --instruction \"$INSTRUCTIONS\""
          fi
          
          # Run with retry logic
          MAX_RETRIES=2
          RETRY_COUNT=0
          SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$SUCCESS" = false ]; do
            echo "Attempt $((RETRY_COUNT + 1)) of $MAX_RETRIES"
            echo "Starting scan at $(date)"
            
            # Run scan with timeout
            timeout ${TIMEFRAME}m bash -c "$CMD" 2>&1 | tee strix_output.log
            EXIT_CODE=${PIPESTATUS[0]}
            
            # Check if it was an API error that we should retry
            if grep -qi "Internal server error\|rate limit\|quota exceeded\|connection reset\|ETIMEDOUT\|ECONNREFUSED" strix_output.log; then
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "API error detected at $(date)"
                echo "Error details from log:"
                grep -i "error\|failed\|exception" strix_output.log | tail -10 || true
                
                # Check CLIProxyAPI status
                echo "Checking CLIProxyAPI status..."
                curl -s "${{ steps.cliproxy.outputs.endpoint }}/models" | jq '.data | length' || echo "CLIProxyAPI not responding!"
                
                # Show recent CLIProxyAPI logs
                echo "Recent CLIProxyAPI logs:"
                tail -30 ~/.cli-proxy-api/cliproxy.log || true
                
                echo "Waiting 15 seconds before retry..."
                sleep 15
                
                # Reduce timeframe for subsequent retries
                REMAINING_TIME=$((TIMEFRAME - 1))
                if [ $REMAINING_TIME -gt 5 ]; then
                  TIMEFRAME=$REMAINING_TIME
                fi
              fi
            else
              SUCCESS=true
            fi
          done
          
          EXIT_CODE=${EXIT_CODE:-1}
          
          # Log the CLIProxyAPI status for debugging
          echo "========================================="
          echo "CLIProxyAPI Status:"
          if [ -f "$HOME/.cli-proxy-api/cliproxy.log" ]; then
            echo "Last 30 lines of CLIProxyAPI log:"
            tail -n 30 "$HOME/.cli-proxy-api/cliproxy.log"
          fi
          echo "========================================="
          
          VULN_COUNT=$(grep -ciE "vulnerability|VULNERABILITY|CVE-|critical|high.*severity" strix_output.log 2>/dev/null || echo "0")
          # Ensure VULN_COUNT is a valid number
          if ! [[ "$VULN_COUNT" =~ ^[0-9]+$ ]]; then
            VULN_COUNT="0"
          fi
          case $EXIT_CODE in
            0)
              echo "Scan completed successfully"
              echo "scan_completed=true" >> "$GITHUB_OUTPUT"
              ;;
            2)
              echo "Scan completed with vulnerabilities found"
              echo "scan_completed=true" >> "$GITHUB_OUTPUT"
              ;;
            124)
              echo "Scan completed (timeframe exhausted)"
              echo "timed_out=true" >> "$GITHUB_OUTPUT"
              echo "scan_completed=true" >> "$GITHUB_OUTPUT"
              ;;
            *)
              echo "Scan completed with exit code: $EXIT_CODE"
              echo "scan_completed=true" >> "$GITHUB_OUTPUT"
              ;;
          esac
          {
            echo "vulnerabilities_found=$VULN_COUNT"
            echo "exit_code=$EXIT_CODE"
          } >> "$GITHUB_OUTPUT"
          echo "::endgroup::"
          exit 0

      - name: Stop Dashboard and Tunnel
        if: always()
        run: |
          set -euo pipefail
          echo "::group::Stopping Dashboard Services"
          
          # Stop tunnel
          if [ -f /tmp/tunnel.pid ]; then
            TUNNEL_PID=$(cat /tmp/tunnel.pid)
            kill $TUNNEL_PID 2>/dev/null || true
            echo "Tunnel stopped (PID: $TUNNEL_PID)"
          fi
          
          # Stop dashboard
          if [ -f /tmp/dashboard.pid ]; then
            DASHBOARD_PID=$(cat /tmp/dashboard.pid)
            kill $DASHBOARD_PID 2>/dev/null || true
            echo "Dashboard stopped (PID: $DASHBOARD_PID)"
          fi
          
          echo "::endgroup::"

      - name: Stop CLIProxyAPI Server
        if: always()
        run: |
          set -euo pipefail
          echo "::group::Stopping CLIProxyAPI"
          AUTH_DIR="$HOME/.cli-proxy-api"
          if [ -f "$AUTH_DIR/cliproxy.pid" ]; then
            PID=$(cat "$AUTH_DIR/cliproxy.pid")
            kill $PID 2>/dev/null || true
            wait $PID 2>/dev/null || true
            echo "CLIProxyAPI stopped (PID: $PID)"
          fi
          if [ -f "$AUTH_DIR/cliproxy.log" ]; then
            echo "=========================================="
            echo "FULL CLIProxyAPI LOGS:"
            echo "=========================================="
            cat "$AUTH_DIR/cliproxy.log"
            echo "=========================================="
          fi
          rm -rf "$AUTH_DIR"/qwen-*.json
          rm -f "$AUTH_DIR/cliproxy.pid"
          echo "::endgroup::"
          
      - name: Upload Scan Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: strixer-results-${{ github.run_id }}
          path: |
            strix_runs/
            strix_output.log
            config.json
            /tmp/dashboard.log
            /tmp/tunnel.log
            /tmp/strix_dashboard_state.json
            ~/.cli-proxy-api/cliproxy.log
          retention-days: 30

      - name: Create Security Summary
        if: always()
        run: |
          set -euo pipefail
          TIMEFRAME="${{ github.event.inputs.timeframe || env.DEFAULT_TIMEFRAME }}"
          VULNS="${{ steps.strix.outputs.vulnerabilities_found }}"
          TIMED_OUT="${{ steps.strix.outputs.timed_out }}"
          TOKEN_COUNT="${{ steps.decrypt.outputs.token_count }}"
          EXIT_CODE="${{ steps.strix.outputs.exit_code }}"
          SCAN_MODE="${{ github.event.inputs.scan_mode || env.DEFAULT_SCAN_MODE }}"
          MODEL="${{ github.event.inputs.model || 'qwen3-coder-plus' }}"
          TARGET="${{ github.event.inputs.target }}"
          DASHBOARD_URL="${{ steps.tunnel.outputs.dashboard_url }}"
          
          # Determine status emoji and text
          if [ "$TIMED_OUT" == "true" ]; then
            STATUS_EMOJI="â°"
            STATUS_TEXT="Scan completed (timeframe exhausted)"
          elif [ "$EXIT_CODE" == "0" ]; then
            STATUS_EMOJI="âœ…"
            STATUS_TEXT="Scan completed successfully"
          elif [ "$EXIT_CODE" == "2" ]; then
            STATUS_EMOJI="ðŸ”´"
            STATUS_TEXT="Scan completed with vulnerabilities found"
          else
            STATUS_EMOJI="âš ï¸"
            STATUS_TEXT="Scan completed with exit code: $EXIT_CODE"
          fi
          
          # Create comprehensive summary
          cat > "$GITHUB_STEP_SUMMARY" << SUMMARY_EOF
          # ðŸ¦‰ Strixer Security Scan Dashboard
          
          ## $STATUS_EMOJI Status: $STATUS_TEXT
          
          ---
          
          ### ðŸ“Š Scan Overview
          
          | Property | Value |
          |----------|-------|
          | **Target** | \`$TARGET\` |
          | **Scan Mode** | $SCAN_MODE |
          | **Model** | $MODEL |
          | **Duration** | $TIMEFRAME minutes |
          | **Qwen Accounts** | $TOKEN_COUNT (load-balanced) |
          | **API Mode** | Direct CLIProxyAPI (No LiteLLM) |
          | **Exit Code** | $EXIT_CODE |
          
          SUMMARY_EOF
          
          # Add dashboard info if available
          if [ -n "$DASHBOARD_URL" ]; then
            cat >> "$GITHUB_STEP_SUMMARY" << DASHEOF
          
          ### ðŸŒ Live Dashboard
          
          The real-time web dashboard was available at:
          \`$DASHBOARD_URL\`
          
          *(Dashboard URL is only active during the scan)*
          
          DASHEOF
          fi
          
          cat >> "$GITHUB_STEP_SUMMARY" << FINDINGSEOF
          
          ### ðŸ” Findings
          
          FINDINGSEOF
          
          # Add vulnerability info
          VULN_NUM=${VULNS:-0}
          if [ "$VULN_NUM" -gt "0" ]; then
            echo "**ðŸ”´ Potential Vulnerabilities Detected: $VULN_NUM**" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "> âš ï¸ Review the detailed report in the workflow artifacts for full analysis." >> "$GITHUB_STEP_SUMMARY"
          else
            echo "**ðŸŸ¢ No vulnerabilities detected in this scan.**" >> "$GITHUB_STEP_SUMMARY"
          fi
          
          # Add configuration features
          cat >> "$GITHUB_STEP_SUMMARY" << 'FEATURES_EOF'
          
          ---
          
          ### âš™ï¸ Configuration Features (Strixer)
          
          - âœ… Multi-Action Mode (up to 7 actions/call)
          - âœ… Qwen Token Load Balancing via CLIProxyAPI
          - âœ… **Direct HTTP API Mode (No LiteLLM)**
          - âœ… Automatic Token Refresh (15-minute intervals)
          - âœ… Health Check Enabled
          - âœ… Request Retry (3 attempts)
          - âœ… Real-Time Web Dashboard
          - âœ… Multi-Agent Collaboration
          
          ---
          
          ### ðŸ“¦ Artifacts
          
          Download the **strixer-results** artifact from this workflow run to access:
          - `strix_runs/` - Detailed scan results and reports
          - `strix_output.log` - Complete scan output log
          - `config.json` - Scan configuration
          - `dashboard.log` - Dashboard server logs
          - `tunnel.log` - Tunnel connection logs
          
          ---
          
          *Generated by [Strixer](https://github.com/Hailer367/strix) - Direct CLIProxyAPI Mode | [Discord Community](https://discord.gg/YjKFvEZSdZ)*
          FEATURES_EOF
          
          echo "âœ… Security summary created"

      - name: Comment on PR with Results
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          script: |
            const timedOut = '${{ steps.strix.outputs.timed_out }}' === 'true';
            const vulnsFound = '${{ steps.strix.outputs.vulnerabilities_found }}' || '0';
            const exitCode = '${{ steps.strix.outputs.exit_code }}';
            const timeframe = '${{ github.event.inputs.timeframe }}' || '${{ env.DEFAULT_TIMEFRAME }}';
            const tokenCount = '${{ steps.decrypt.outputs.token_count }}';
            const dashboardUrl = '${{ steps.tunnel.outputs.dashboard_url }}';
            const model = '${{ github.event.inputs.model }}' || 'qwen3-coder-plus';

            let summary = '## Strixer Security Scan Results\\n\\n';
            if (timedOut) {
              summary += `**Status:** Scan completed (full ${timeframe} minutes used)\\n\\n`;
            } else {
              summary += '**Status:** Scan Completed\\n\\n';
            }
            if (parseInt(vulnsFound) > 0) {
              summary += `**Potential Vulnerabilities:** ${vulnsFound} identified\\n\\n`;
              summary += 'Review the detailed report in workflow artifacts.\\n\\n';
            } else {
              summary += '**No vulnerabilities found**\\n\\n';
            }
            summary += `**Scan Mode:** ${{ github.event.inputs.scan_mode || env.DEFAULT_SCAN_MODE }}\\n`;
            summary += `**Timeframe:** ${timeframe} minutes\\n`;
            summary += `**Model:** ${model}\\n`;
            summary += `**Qwen Accounts:** ${tokenCount} (load-balanced)\\n`;
            summary += `**API Mode:** Direct CLIProxyAPI (No LiteLLM)\\n`;
            summary += `**Exit Code:** ${exitCode}\\n\\n`;
            summary += '### Features:\\n';
            summary += '- Multi-Action Mode (7 actions/call)\\n';
            summary += '- Direct CLIProxyAPI HTTP Integration\\n';
            summary += '- Qwen Token Load Balancing\\n';
            summary += '- Real-Time Web Dashboard\\n';
            summary += '- Multi-Agent Collaboration\\n\\n';
            summary += `[View Full Results](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})\\n`;

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: summary
            });
